---
domain: rg.cape.io # This is the cache CNAME used for the virtual server on the compile server. CNAME that domain to cache.cape.io and it will serve the compiled website.
uid: 1 # The CAPE user ID to use for authenticating against the providers when requesting API resources. This needs to be updated to the correct uid.
cape_version: 2.1.3 # Current version of cape can be found in Kai's head. Future at v2.cape.io/version

load:
  #- "http://v2.cape.io/rg/_api/items/_load.json"
  - "http://v2.cape.io/rg/_api/gh_repo/_load.json"
  - "http://v2.cape.io/rg/_model/items/model_fields_add.json"
  - "http://v2.cape.io/rg/_model/files/model_fields_reload.json"
  - "http://v2.cape.io/rg/_model/template/model_fields_reload.json"
  - "http://v2.cape.io/rg/_model/pages/model_fields_reload.json"
  - "http://v2.cape.io/rg/_view/_all/process.json"

api: # An API as a collection of content.

  old_demo: # Used to get content from old github repo.
    provider: github
    arg:
      owner: ookb
      repo: rogersgoffigon
      branch: gh-pages
    load: # To load previously created content from this API you need to specificy the load param.
      resource: tree # Github has a nice index of all content in a repo.
      _id: path
      arg:
        recursive: true # Thankfully they have an option to get results recursively.
        sha: gh-pages

  gh_repo: # Used to get content from the big heavy github repo.
    provider: github
    arg:
      owner: bjornmeansbear
      repo: rogers-and-goffigon
      branch: master
    load:
      resource: tree
      _id: path
      arg:
        recursive: true
        sha: master

  db: # Accept any post with make_id rg...
    provider: post
    arg:
      make_id: rg

  # An API defined for accepting posts.
  items: # Get item content from a json file.
    provider: post
    arg:
      id: rg
      source: pdf_csv
    load:
      provider: wget
      resource: json
      _id: itemnum
      arg:
        url: http://rg.cape.io/items/index_full.json
      field:
        _source: _self

model:
  db:
    filter:
      api: db

  template:
    filter:
      api: gh_repo
      must:
        _dirname: templates
    field:
      _self:
        api: gh_repo
        resource: raw_api
        type: yaml_front
        default: default.html
        arg:
          path: '{{&_id}}'

  mini_templates:
    type: set
    set_key: _filename
    filter:
      api: gh_repo
      must:
        _dirname: templates/mini
    field:
      _self:
        api: gh_repo
        resource: raw_api
        type: any
        arg:
          path: '{{&_id}}'

  files:
    type: files
    filter:
      api: gh_repo
      should:
        _ext: ['.jpg', '.jpeg', '.png', '.css', '.js', '.ico', '.gif', '.html', '.ttf']
      must_not:
        _dir1: reference
    file:
      source_file:
        api: gh_repo
        resource: raw_api
        file_id: '{{&_id}}'
        type: any
        arg:
          path: '{{&_id}}'

  data:
    type: object
    filter:
      api: gh_repo
      must:
        _id: content/data.yaml
    field: # The base "entity" in CAPE is the _id field. That's it.
      # To get the contents of the file we need to add a "meta-field"
      _self: # _self is a special meta-field that will place its own fields within the base context.
        file_id: 'data.json' # When the _file field has a value it saves that field as a file.
        api: gh_repo # The _self field is processed first.
        resource: raw_api # This just defines what API at github to use.
        type: yaml # This tells CAPE what to do with the file that it gets. This should default to the file extension.
        arg:
          path: '{{&_id}}' # The raw github API call requires a path param.

  beautyshots:
    type: object
    filter:
      api: gh_repo
      must:
        _id: beautyshots/index.yaml
    field: # The base "entity" in CAPE is the _id field. That's it.
      # To get the contents of the file we need to add a "meta-field"
      _self: # _self is a special meta-field that will place its own fields within the base context.
        file_id: 'beautyshots/index.json' # When the _file field has a value it saves that field as a file.
        api: gh_repo # The _self field is processed first.
        resource: raw_api # This just defines what API at github to use.
        type: yaml # This tells CAPE what to do with the file that it gets. This should default to the file extension.
        arg:
          path: '{{&_id}}' # The raw github API call requires a path param.

  pages:
    type: list
    filter:
      api: gh_repo
      must:
        _dir1: content
        _ext: .md
    field:
      _self:
        api: gh_repo
        resource: raw_api
        type: md
        arg:
          path: '{{&_id}}'

  items:
    limit: 3000
    type: list
    filter:
      api: items
      must_not:
        _id: TRIMBOOK
    field:
      color_id:
        app: map
        func: last_dash
        arg: '{{&_id}}'
      contents:
        app: map
        func: split
        arg:
          string: '{{&contentdesc}}'
          split_on: ', '
          split_on_sub: ' '
          compact: true
      colors:
        app: map
        func: split
        arg:
          string: '{{&primarycolor}}, {{&secondarycolor}}'
          split_on: ', '
          unique: true
          compact: true
      design_descriptions:
        app: map
        func: split
        arg:
          string: '{{&designdesc}}'
          split_on: ', '
          split_on_sub: ' '
          unique: true
          compact: true
      use:
        app: map
        func: string_replace
        arg:
          string: '{{&miscdesc}}'
          split_on: ', '
          find_replace:
            A: Accessories
            D: Draperies
            U: Upholstery
            WC: Wall Covering
            SC: Slip Covers
    sort:
      field: sort

  textile:
    limit: 3000
    type: list
    filter:
      api: items
      must:
        _char1int: true
    field:
      collection: textile
      img:
        app: rg
        func: img_checker
        arg:
          itemid: '{{&_id}}'
          include_far: true
      uses:
        app: map
        func: split
        arg:
          split_on: ','
          unique: true
          compact: true
          trim: true
    sort:
      field: sort

  passementerie:
    type: list
    filter:
      api: items
      must:
        _char1: P
    field:
      collection: passementerie
      img:
        app: rg
        func: img_checker
        arg:
          itemid: '{{&_id}}'
    sort:
      field: sort

  leather:
    type: list
    filter:
      api: items
      must:
        _char1: L
    field:
      collection: leather
      img:
        app: rg
        func: img_checker
        arg:
          itemid: '{{&_id}}'
    sort:
      field: sort

view:

  pages: # These are the pages besides items.
    type: string
    field:
      date:
        app: map
        func: date_obj
      data: true
      pages: true
      items: true
      textile_content_filters: content_ops
      color_ops_textile: color_ops_textile
      color_ops_passementerie: color_ops_passementerie
      color_ops_leather: color_ops_leather
      design_descriptions: design_descriptions
      theme:
        model: db
        _id: theme
    pager:
      iterate: pages # for each item in the list from the model pages
      field_id: page # field name for the item
      map:
        data: navigation
      template: # This field will be accessible using this field name in mustache.
        partial: # Add it to the view template as a partial.
          page_template: # If this template is an object the key is field name.
            model: template # Load same way as you load a template.
            _id: '{{^page.template}}{{page._filename}}{{/page.template}}{{page.template}}.html'
      file_id: '{{#page._dir2}}{{&page._dir2}}/{{/page._dir2}}{{&page._filename}}.html'
    template:
      model: template
      _id: default.html

  # price_list: # Saved to trade/pricelist.json
  #   type: list
  #   output_id: trade/pricelist.json
  #   field:
  #     items: true
  #   pager:
  #     iterate: items
  #     field_id: item
  #   emit:
  #     name: '{{&item.descript_1}}'
  #     color: '{{&item.descript_2}}'
  #     id: '{{&item._id}}'
  #     content: '{{&item.content}}'
  #     repeat: '{{&item.repeat}}'
  #     width: '{{&item.width}}'
  #     price: '{{&item.price}}' # This price field should be removed when we go live.

  collection: # Saved to items/items.json
    type: list
    field:
      items: true
    pager:
      iterate: items
      field_id: item
    emit:
      name: '{{&item.descript_1}}'
      color: '{{&item.descript_2}}'
      primarycolor: '{{item.primarycolor}}'
      secondarycolor: '{{item.secondarycolor}}'
      id: '{{item._id}}'
      content: '{{&item.content}}'
      repeat: '{{&item.repeat}}'
      width: '{{&item.width}}'
      img: '{{&item.img.normal.640}}'
      collection: '{{item.collection}}'
      design_descriptions: '{{#item.design_descriptions}}{{.}} {{/item.design_descriptions}}'

  price:
    type: set
    field:
      _data:
        model: items
        pluck: price
        index_by: _id
    output_id: items/price.json

  colors:
    type: set
    field:
      _data:
        model: items
        group_by: patternnum
        pluck: color_id

  mini_templates:
    type: set
    field:
      _data:
        model: mini_templates
        pluck: content

  content_ops:
    type: list
    field:
      _data:
        model: textile
        pluck: contents
        flatten: true
        unique: true
        compact: true

  color_ops_textile:
    type: list
    field:
      _data:
        model: textile
        pluck: colors
        flatten: true
        unique: true
        compact: true

  color_ops_passementerie:
    type: list
    field:
      _data:
        model: passementerie
        pluck: descript_2
        flatten: true
        unique: true
        compact: true

  color_ops_leather:
    type: list
    field:
      _data:
        model: leather
        pluck: descript_2
        flatten: true
        unique: true
        compact: true

  design_descriptions:
    type: list
    field:
      _data:
        model: textile
        pluck: design_descriptions
        flatten: true
        unique: true
        compact: true

  miscdesc:
    type: list
    field:
      _data:
        model: textile
        pluck: miscdesc
        flatten: true
        unique: true
        compact: true

  use:
    type: list
    field:
      _data:
        model: textile
        pluck: use
        flatten: true
        unique: true
        compact: true

  # Big huge thing used client side for database.
  client_data:
    type: object
    output_id: items/client_data.json
    field:
      color_words: color_ops_textile
      colors: colors
      items: collection
      templates: mini_templates
